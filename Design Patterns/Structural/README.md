# Structural Design Pattern

These design patterns are about organizing different classes and objects to form larger structures and provide new functionality.
Structural design patterns are Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Private Class Data, and Proxy.

Use Case Of Structural Design Pattern-
When 2 interfaces are not compatible with each other and want to establish a relationship between them through an adapter itâ€™s called an adapter design pattern. Adapter pattern converts the interface of a class into another interface or class that the client expects, i.e adapter lets classes works together that could not otherwise because of incompatibility. so in these type of incompatible scenarios, we can go for the adapter pattern.

1. [Adapter](./Adapter) - Match interfaces of different classes
1. [Bridge](./Bridge) - Separates an object's interface from its implementation
1. [Composite](./Composite) - A tree structure of simple and composite objects
1. [Decorator](./Decorator) - Add responsibilities to objects dynamically
1. [Facade](./Facade) - A single class that represents an entire subsystem
1. [Flyweight](./Flyweight) - A fine-grained instance used for efficient sharing
1. [Private Pattern](./Private_Pattern) Class Data - Restricts accessor/mutator access
1. [Proxy](./Proxy) - An object representing another object
